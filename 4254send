#!/usr/bin/python3 -u
#


import sys
import socket
import time
import datetime
import select
import json

from base64 import b64encode
from datetime import datetime
from enum import Enum
import traceback 



MSG_SIZE = 1500
# Currently at threshold with no added headers
DATA_SIZE = 1050 # TODO CHANGE THIS
TIMEOUT = 0.2
PACKETNUM = 0
EXPECTED_ACK_NUM = 0
TIMEOUT_COUNTER = 1

#CP3
WINDOW = 1
SSTHRESH = 32
DUPLICATE_COUNTER = 0


# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

time.sleep(0.5)

in_flight_packets = {}


# Get the current date and time
current_time = datetime.now()
log_file_name = current_time.strftime("data/log_%Y%m%d%H%M%S.txt")
file = open(log_file_name, 'a')
file.write("Starting Test, Timestamp: {}\n".format(current_time))

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
  #logging takes away from time
  #placeholder=1
  sys.stderr.write(datetime.now().strftime("%H:%M:%S.%f") + " 4254send: " + string + "\n")


def congestion_control(type):
  global WINDOW, SSTHRESH
  file.write('CCA Mode: '+ type +'\n')
  if type == "SS":
    WINDOW = WINDOW * 2
  elif type == "CA":
    WINDOW = WINDOW + 1
  elif type == "FR":
    WINDOW = max(WINDOW // 2, 1)
  elif type == "TO":
    WINDOW = 1xs
    SSTHRESH = max(SSTHRESH // 2, 1)

def send_next_packet():
  global PACKETNUM
  global msg

  data = sys.stdin.buffer.read(DATA_SIZE)
  if (len(data) > 0):
    msg = json.dumps({"sequence": PACKETNUM, "data": b64encode(data).decode(), "ack": False, "eof": False,  "cwnd": WINDOW})
    # Calculate the number of bytes in the serialized JSON string
    # msg_bytes = len(msg.encode())
    # log("Size of 'msg' in bytes: " + str(msg_bytes))
    in_flight_packets[PACKETNUM] = msg
    if sock.sendto(msg.encode(), dest) < len(msg):
      log("[error] unable to fully send packet")
    else:
      log("[send data] " + str(PACKETNUM))
    PACKETNUM+=1
    return True
  else:
    return False
  

# Send first window
for i in range(WINDOW):
  if( not send_next_packet()):
    break

# Now read in data, send packets
while in_flight_packets:
  log("ABOUT TO SLEEP")
  # Write content to the file
  file.write('Window Size: '+ str(WINDOW) +'\n')
  try: 
    result = sock.recvfrom(MSG_SIZE)
    if result:
      (data, addr) = result
      try:
        decoded = json.loads(data.decode())
        if decoded['ack'] in in_flight_packets:
          log("[in_flight_packets] deleting " + str(decoded['ack']))
          del in_flight_packets[decoded['ack']]
          # If there is an ack, send next packet
          if decoded['ack'] == EXPECTED_ACK_NUM:
            log("[recv pkt] recieved expected packet")
            # If the ack is what is expected, move the window
            if WINDOW < SSTHRESH:
              congestion_control("SS")
            else:
              congestion_control("CA")
            EXPECTED_ACK_NUM += 1
            DUPLICATE_COUNTER = 0
          else:
            # Resend the packet it was expecting
            log("[recv pkt] recieved unexpected packet")
            DUPLICATE_COUNTER += 1
            if DUPLICATE_COUNTER == 3:
              congestion_control("FR")
              DUPLICATE_COUNTER = 0
            while len(in_flight_packets) != 0 and EXPECTED_ACK_NUM not in in_flight_packets:
              EXPECTED_ACK_NUM+=1
            log("[send data] resending " + str(EXPECTED_ACK_NUM))
            sock.sendto(in_flight_packets[EXPECTED_ACK_NUM].encode(), dest)

        while(len(in_flight_packets) < WINDOW ):
          if( not send_next_packet()):
            break
      except (ValueError, KeyError, TypeError) as e:
        traceback.print_exc() 
        log("[recv corrupt packet] Error: {}".format(str(e)))
        
  except socket.timeout:
    # We need to resend the packet if a timeout is hit (using the sequence number)
    TIMEOUT_COUNTER+=1
    DUPLICATE_COUNTER = 0
    log("[error] timeout, resending last packet")
    while EXPECTED_ACK_NUM not in in_flight_packets:
      EXPECTED_ACK_NUM+=1
    
    # ssthresh = cwnd/2 (decrease the slow start threshold)
    # cwnd = MSS (restart slow start)
    congestion_control("TO")
    # retransmit lost packet
    sock.sendto(in_flight_packets[EXPECTED_ACK_NUM].encode(), dest)


  
log("Sending EOF Packet")
for i in range(int(TIMEOUT_COUNTER)):
  msg = json.dumps({"eof": True, "data": "", "sequence": PACKETNUM, "ack": False, "cwnd": WINDOW})
  sock.sendto(msg.encode(), dest)

file.close()

log("[completed] closing connection")
sys.exit(0)
